// automatically generated by the FlatBuffers compiler, do not modify

package Common

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type GamePlayState struct {
	_tab flatbuffers.Table
}

func GetRootAsGamePlayState(buf []byte, offset flatbuffers.UOffsetT) *GamePlayState {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GamePlayState{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *GamePlayState) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GamePlayState) GameStatus() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateGameStatus(n byte) bool {
	return rcv._tab.MutateByteSlot(4, n)
}

func (rcv *GamePlayState) WallTileCount() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateWallTileCount(n byte) bool {
	return rcv._tab.MutateByteSlot(6, n)
}

func (rcv *GamePlayState) DrawFront() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateDrawFront(n byte) bool {
	return rcv._tab.MutateByteSlot(8, n)
}

func (rcv *GamePlayState) DrawBehind() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateDrawBehind(n byte) bool {
	return rcv._tab.MutateByteSlot(10, n)
}

func (rcv *GamePlayState) RoomInfo(obj *RoomInfo) *RoomInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(RoomInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *GamePlayState) RoomUserList(obj *RoomUserInfo, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		if obj == nil {
			obj = new(RoomUserInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GamePlayState) RoomUserListLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) Dice(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *GamePlayState) DiceLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) DiceBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GamePlayState) Dealer() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateDealer(n uint32) bool {
	return rcv._tab.MutateUint32Slot(18, n)
}

func (rcv *GamePlayState) DealCount() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateDealCount(n byte) bool {
	return rcv._tab.MutateByteSlot(20, n)
}

func (rcv *GamePlayState) CurrentRound() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateCurrentRound(n byte) bool {
	return rcv._tab.MutateByteSlot(22, n)
}

func (rcv *GamePlayState) LastPlayerId() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateLastPlayerId(n uint32) bool {
	return rcv._tab.MutateUint32Slot(24, n)
}

func (rcv *GamePlayState) CurrentPlayerId() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateCurrentPlayerId(n uint32) bool {
	return rcv._tab.MutateUint32Slot(26, n)
}

func (rcv *GamePlayState) MahjongUserInfo(obj *MahjongUserInfo, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		if obj == nil {
			obj = new(MahjongUserInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GamePlayState) MahjongUserInfoLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) ChikenRoller() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateChikenRoller(n byte) bool {
	return rcv._tab.MutateByteSlot(30, n)
}

func (rcv *GamePlayState) ChikenRollerIndex() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateChikenRollerIndex(n byte) bool {
	return rcv._tab.MutateByteSlot(32, n)
}

func (rcv *GamePlayState) ChikenDraw() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateChikenDraw(n byte) bool {
	return rcv._tab.MutateByteSlot(34, n)
}

func (rcv *GamePlayState) PrepareStatus() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutatePrepareStatus(n byte) bool {
	return rcv._tab.MutateByteSlot(36, n)
}

func (rcv *GamePlayState) PrepareUsers(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *GamePlayState) PrepareUsersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) LackStatus() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateLackStatus(n byte) bool {
	return rcv._tab.MutateByteSlot(40, n)
}

func (rcv *GamePlayState) DismissRemainTime() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateDismissRemainTime(n uint32) bool {
	return rcv._tab.MutateUint32Slot(42, n)
}

func (rcv *GamePlayState) DismissUsers(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *GamePlayState) DismissUsersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) GameEnterPush(obj *GameEnterPush) *GameEnterPush {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(GameEnterPush)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *GamePlayState) ClientOperationPushArray(obj *ClientOperationPush, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		if obj == nil {
			obj = new(ClientOperationPush)
		}
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GamePlayState) ClientOperationPushArrayLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) OperationPushArray(obj *OperationPush, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		if obj == nil {
			obj = new(OperationPush)
		}
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GamePlayState) OperationPushArrayLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) UserOperationPushArray(obj *UserOperationPush, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		if obj == nil {
			obj = new(UserOperationPush)
		}
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GamePlayState) UserOperationPushArrayLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) GameSettlementPush(obj *GameSettlementPush) *GameSettlementPush {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(GameSettlementPush)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *GamePlayState) HostingUser(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *GamePlayState) HostingUserLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) LackedUsers(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *GamePlayState) LackedUsersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) TingTiles(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *GamePlayState) TingTilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) TingTilesBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GamePlayState) MahjongUserInfoV210(obj *MahjongUserInfo_v_2_1_0, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		if obj == nil {
			obj = new(MahjongUserInfo_v_2_1_0)
		}
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GamePlayState) MahjongUserInfoV210Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GamePlayState) Step() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateStep(n uint16) bool {
	return rcv._tab.MutateUint16Slot(64, n)
}

func (rcv *GamePlayState) RaceInfo(obj *Race) *Race {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Race)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *GamePlayState) RaceRank() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateRaceRank(n int32) bool {
	return rcv._tab.MutateInt32Slot(68, n)
}

func (rcv *GamePlayState) ConsumeCoin() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateConsumeCoin(n int32) bool {
	return rcv._tab.MutateInt32Slot(70, n)
}

func (rcv *GamePlayState) MultipleRound() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateMultipleRound(n int32) bool {
	return rcv._tab.MutateInt32Slot(72, n)
}

func (rcv *GamePlayState) ExchangeStatus() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GamePlayState) MutateExchangeStatus(n byte) bool {
	return rcv._tab.MutateByteSlot(74, n)
}

func GamePlayStateStart(builder *flatbuffers.Builder) {
	builder.StartObject(36)
}
func GamePlayStateAddGameStatus(builder *flatbuffers.Builder, gameStatus byte) {
	builder.PrependByteSlot(0, gameStatus, 0)
}
func GamePlayStateAddWallTileCount(builder *flatbuffers.Builder, wallTileCount byte) {
	builder.PrependByteSlot(1, wallTileCount, 0)
}
func GamePlayStateAddDrawFront(builder *flatbuffers.Builder, drawFront byte) {
	builder.PrependByteSlot(2, drawFront, 0)
}
func GamePlayStateAddDrawBehind(builder *flatbuffers.Builder, drawBehind byte) {
	builder.PrependByteSlot(3, drawBehind, 0)
}
func GamePlayStateAddRoomInfo(builder *flatbuffers.Builder, roomInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(roomInfo), 0)
}
func GamePlayStateAddRoomUserList(builder *flatbuffers.Builder, roomUserList flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(roomUserList), 0)
}
func GamePlayStateStartRoomUserListVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddDice(builder *flatbuffers.Builder, dice flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(dice), 0)
}
func GamePlayStateStartDiceVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func GamePlayStateAddDealer(builder *flatbuffers.Builder, dealer uint32) {
	builder.PrependUint32Slot(7, dealer, 0)
}
func GamePlayStateAddDealCount(builder *flatbuffers.Builder, dealCount byte) {
	builder.PrependByteSlot(8, dealCount, 0)
}
func GamePlayStateAddCurrentRound(builder *flatbuffers.Builder, currentRound byte) {
	builder.PrependByteSlot(9, currentRound, 0)
}
func GamePlayStateAddLastPlayerId(builder *flatbuffers.Builder, lastPlayerId uint32) {
	builder.PrependUint32Slot(10, lastPlayerId, 0)
}
func GamePlayStateAddCurrentPlayerId(builder *flatbuffers.Builder, currentPlayerId uint32) {
	builder.PrependUint32Slot(11, currentPlayerId, 0)
}
func GamePlayStateAddMahjongUserInfo(builder *flatbuffers.Builder, mahjongUserInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(mahjongUserInfo), 0)
}
func GamePlayStateStartMahjongUserInfoVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddChikenRoller(builder *flatbuffers.Builder, chikenRoller byte) {
	builder.PrependByteSlot(13, chikenRoller, 0)
}
func GamePlayStateAddChikenRollerIndex(builder *flatbuffers.Builder, chikenRollerIndex byte) {
	builder.PrependByteSlot(14, chikenRollerIndex, 0)
}
func GamePlayStateAddChikenDraw(builder *flatbuffers.Builder, chikenDraw byte) {
	builder.PrependByteSlot(15, chikenDraw, 0)
}
func GamePlayStateAddPrepareStatus(builder *flatbuffers.Builder, prepareStatus byte) {
	builder.PrependByteSlot(16, prepareStatus, 0)
}
func GamePlayStateAddPrepareUsers(builder *flatbuffers.Builder, prepareUsers flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(prepareUsers), 0)
}
func GamePlayStateStartPrepareUsersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddLackStatus(builder *flatbuffers.Builder, lackStatus byte) {
	builder.PrependByteSlot(18, lackStatus, 0)
}
func GamePlayStateAddDismissRemainTime(builder *flatbuffers.Builder, dismissRemainTime uint32) {
	builder.PrependUint32Slot(19, dismissRemainTime, 0)
}
func GamePlayStateAddDismissUsers(builder *flatbuffers.Builder, dismissUsers flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(20, flatbuffers.UOffsetT(dismissUsers), 0)
}
func GamePlayStateStartDismissUsersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddGameEnterPush(builder *flatbuffers.Builder, gameEnterPush flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(gameEnterPush), 0)
}
func GamePlayStateAddClientOperationPushArray(builder *flatbuffers.Builder, clientOperationPushArray flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(clientOperationPushArray), 0)
}
func GamePlayStateStartClientOperationPushArrayVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddOperationPushArray(builder *flatbuffers.Builder, operationPushArray flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(23, flatbuffers.UOffsetT(operationPushArray), 0)
}
func GamePlayStateStartOperationPushArrayVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddUserOperationPushArray(builder *flatbuffers.Builder, userOperationPushArray flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(24, flatbuffers.UOffsetT(userOperationPushArray), 0)
}
func GamePlayStateStartUserOperationPushArrayVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddGameSettlementPush(builder *flatbuffers.Builder, gameSettlementPush flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(25, flatbuffers.UOffsetT(gameSettlementPush), 0)
}
func GamePlayStateAddHostingUser(builder *flatbuffers.Builder, hostingUser flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(26, flatbuffers.UOffsetT(hostingUser), 0)
}
func GamePlayStateStartHostingUserVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddLackedUsers(builder *flatbuffers.Builder, lackedUsers flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(27, flatbuffers.UOffsetT(lackedUsers), 0)
}
func GamePlayStateStartLackedUsersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddTingTiles(builder *flatbuffers.Builder, tingTiles flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(28, flatbuffers.UOffsetT(tingTiles), 0)
}
func GamePlayStateStartTingTilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func GamePlayStateAddMahjongUserInfoV210(builder *flatbuffers.Builder, mahjongUserInfoV210 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(29, flatbuffers.UOffsetT(mahjongUserInfoV210), 0)
}
func GamePlayStateStartMahjongUserInfoV210Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GamePlayStateAddStep(builder *flatbuffers.Builder, step uint16) {
	builder.PrependUint16Slot(30, step, 0)
}
func GamePlayStateAddRaceInfo(builder *flatbuffers.Builder, raceInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(31, flatbuffers.UOffsetT(raceInfo), 0)
}
func GamePlayStateAddRaceRank(builder *flatbuffers.Builder, raceRank int32) {
	builder.PrependInt32Slot(32, raceRank, 0)
}
func GamePlayStateAddConsumeCoin(builder *flatbuffers.Builder, consumeCoin int32) {
	builder.PrependInt32Slot(33, consumeCoin, 0)
}
func GamePlayStateAddMultipleRound(builder *flatbuffers.Builder, multipleRound int32) {
	builder.PrependInt32Slot(34, multipleRound, 0)
}
func GamePlayStateAddExchangeStatus(builder *flatbuffers.Builder, exchangeStatus byte) {
	builder.PrependByteSlot(35, exchangeStatus, 0)
}
func GamePlayStateEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
