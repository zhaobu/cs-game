// automatically generated by the FlatBuffers compiler, do not modify

package Common

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type League struct {
	_tab flatbuffers.Table
}

func GetRootAsLeague(buf []byte, offset flatbuffers.UOffsetT) *League {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &League{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *League) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *League) Id() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateId(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *League) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *League) Icon() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateIcon(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *League) LeagueType() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateLeagueType(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func (rcv *League) GameType() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateGameType(n uint16) bool {
	return rcv._tab.MutateUint16Slot(12, n)
}

func (rcv *League) Setting(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *League) SettingLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *League) SettingBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *League) RequireUserCount() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateRequireUserCount(n int32) bool {
	return rcv._tab.MutateInt32Slot(16, n)
}

func (rcv *League) SignupUserCount() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateSignupUserCount(n int32) bool {
	return rcv._tab.MutateInt32Slot(18, n)
}

func (rcv *League) Price() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutatePrice(n int32) bool {
	return rcv._tab.MutateInt32Slot(20, n)
}

func (rcv *League) SignupTime() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateSignupTime(n int64) bool {
	return rcv._tab.MutateInt64Slot(22, n)
}

func (rcv *League) GiveupTime() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateGiveupTime(n int64) bool {
	return rcv._tab.MutateInt64Slot(24, n)
}

func (rcv *League) StartTime() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateStartTime(n int64) bool {
	return rcv._tab.MutateInt64Slot(26, n)
}

func (rcv *League) Rewards(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *League) RewardsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *League) Weight() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateWeight(n int32) bool {
	return rcv._tab.MutateInt32Slot(30, n)
}

func (rcv *League) RequireUserMin() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateRequireUserMin(n int32) bool {
	return rcv._tab.MutateInt32Slot(32, n)
}

func (rcv *League) PriceEntityId() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutatePriceEntityId(n int32) bool {
	return rcv._tab.MutateInt32Slot(34, n)
}

func (rcv *League) Img() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *League) Category() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *League) MutateCategory(n byte) bool {
	return rcv._tab.MutateByteSlot(38, n)
}

func LeagueStart(builder *flatbuffers.Builder) {
	builder.StartObject(18)
}
func LeagueAddId(builder *flatbuffers.Builder, id int32) {
	builder.PrependInt32Slot(0, id, 0)
}
func LeagueAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func LeagueAddIcon(builder *flatbuffers.Builder, icon int32) {
	builder.PrependInt32Slot(2, icon, 0)
}
func LeagueAddLeagueType(builder *flatbuffers.Builder, leagueType int32) {
	builder.PrependInt32Slot(3, leagueType, 0)
}
func LeagueAddGameType(builder *flatbuffers.Builder, gameType uint16) {
	builder.PrependUint16Slot(4, gameType, 0)
}
func LeagueAddSetting(builder *flatbuffers.Builder, setting flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(setting), 0)
}
func LeagueStartSettingVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func LeagueAddRequireUserCount(builder *flatbuffers.Builder, requireUserCount int32) {
	builder.PrependInt32Slot(6, requireUserCount, 0)
}
func LeagueAddSignupUserCount(builder *flatbuffers.Builder, signupUserCount int32) {
	builder.PrependInt32Slot(7, signupUserCount, 0)
}
func LeagueAddPrice(builder *flatbuffers.Builder, price int32) {
	builder.PrependInt32Slot(8, price, 0)
}
func LeagueAddSignupTime(builder *flatbuffers.Builder, signupTime int64) {
	builder.PrependInt64Slot(9, signupTime, 0)
}
func LeagueAddGiveupTime(builder *flatbuffers.Builder, giveupTime int64) {
	builder.PrependInt64Slot(10, giveupTime, 0)
}
func LeagueAddStartTime(builder *flatbuffers.Builder, startTime int64) {
	builder.PrependInt64Slot(11, startTime, 0)
}
func LeagueAddRewards(builder *flatbuffers.Builder, rewards flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(rewards), 0)
}
func LeagueStartRewardsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LeagueAddWeight(builder *flatbuffers.Builder, weight int32) {
	builder.PrependInt32Slot(13, weight, 0)
}
func LeagueAddRequireUserMin(builder *flatbuffers.Builder, requireUserMin int32) {
	builder.PrependInt32Slot(14, requireUserMin, 0)
}
func LeagueAddPriceEntityId(builder *flatbuffers.Builder, priceEntityId int32) {
	builder.PrependInt32Slot(15, priceEntityId, 0)
}
func LeagueAddImg(builder *flatbuffers.Builder, img flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(img), 0)
}
func LeagueAddCategory(builder *flatbuffers.Builder, category byte) {
	builder.PrependByteSlot(17, category, 0)
}
func LeagueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
